import { Type } from "@google/genai";

export const GEMINI_MODEL = 'gemini-2.5-flash';

export const ANALYSIS_SYSTEM_INSTRUCTION = `You are a professional QA Test Planner and Product Manager Assistant. 
Your task is to perform a structured static review of the provided inputs, which may include a Product Requirements Document (PRD), UI mockups as images (from uploads or Figma), and descriptions of video flows.
Analyze all provided materials holistically. 
Identify logical gaps from the PRD, and UI/UX issues, accessibility problems, or inconsistencies from the visual materials.
For each finding, cite the relevant User Story ID if possible.
Provide your findings in a structured JSON format according to the provided schema.`;

export const ANALYSIS_RESPONSE_SCHEMA = {
  type: Type.OBJECT,
  properties: {
    findings: {
      type: Type.ARRAY,
      description: 'A list of gaps, ambiguities, or missing information in the PRD and visual materials.',
      items: {
        type: Type.OBJECT,
        properties: {
          category: {
            type: Type.STRING,
            description: 'The type of finding (e.g., "Missing Acceptance Criteria", "UI/UX Inconsistency", "Accessibility Issue", "Undefined Edge Case").'
          },
          description: {
            type: Type.STRING,
            description: 'A detailed explanation of the finding.'
          },
          source_story_id: {
            type: Type.STRING,
            description: 'The User Story ID (e.g., US-101) related to this finding, if applicable.'
          }
        },
        required: ['category', 'description']
      }
    }
  },
  required: ['findings']
};


export const TEST_PLAN_SYSTEM_INSTRUCTION = `You are an expert QA Test Planner. Based on the provided Product Requirements Document (PRD), visual designs, and an initial analysis of its gaps, generate a comprehensive test plan.
The output must be a JSON object containing two keys: 'markdown' and 'gherkin'.
The 'markdown' value must be a Markdown table with the following columns: 'Test Case ID', 'Test Type', 'Summary', 'Preconditions', 'Test Steps', 'Expected Result', 'Story ID', and 'Risk Type'.
The 'Test Steps' should use '→' as a delimiter between steps.
The 'gherkin' value must be a string containing corresponding Gherkin scenarios for automation.
Ensure the test cases cover functional happy paths, error flows, and boundary conditions based on ALL provided materials (text and visuals).`;

export const TEST_PLAN_RESPONSE_SCHEMA = {
    type: Type.OBJECT,
    properties: {
        markdown: {
            type: Type.STRING,
            description: "A Markdown-formatted table of test cases."
        },
        gherkin: {
            type: Type.STRING,
            description: "Gherkin scenarios for BDD automation."
        }
    },
    required: ['markdown', 'gherkin']
};

export const CONSOLIDATE_SYSTEM_INSTRUCTION = `You are an expert QA Test Lead. You have been given three draft test plans generated by different AI assistants for the same set of requirements (PRD and visual designs).
Your task is to synthesize these drafts into a single, definitive, and high-quality test plan.
You must:
1.  De-duplicate test cases, merging similar ones to avoid redundancy.
2.  Ensure complete coverage of happy paths, edge cases, and error conditions mentioned in any of the drafts.
3.  Harmonize the 'Test Case ID' format to be consistent (e.g., TC-001, TC-002).
4.  Produce a final, clean JSON output with 'markdown' and 'gherkin' keys, following the provided schema.
The final output should be the best possible version, combining the strengths of all three drafts.`;

export const PRIORITIZATION_SYSTEM_INSTRUCTION = `You are a Principal QA Engineer. You have been given a list of test cases.
Your task is to assign a priority level to each test case and provide a brief justification.
Priority Levels:
- P0 (Critical): Must-pass for release. Blocks key functionality, high user impact, or major security risk.
- P1 (High): Important functionality. Should be tested, but not a release blocker if a workaround exists.
- P2 (Medium): Minor functionality, cosmetic issues, or low-impact edge cases.
- P3 (Low): Nice-to-have features or very unlikely scenarios.

Analyze each test case's summary, risk, and steps to determine its priority.
Return a JSON object containing a 'prioritized_cases' array, according to the provided schema. The order of cases in your response must match the order of cases in the input.`;

export const PRIORITIZATION_RESPONSE_SCHEMA = {
  type: Type.OBJECT,
  properties: {
    prioritized_cases: {
      type: Type.ARRAY,
      description: 'The list of test cases, each with an assigned priority and reasoning.',
      items: {
        type: Type.OBJECT,
        properties: {
          test_case_id: {
            type: Type.STRING,
            description: "The ID of the test case being prioritized (e.g., 'TC-001')."
          },
          priority: {
            type: Type.STRING,
            description: "The assigned priority level (P0, P1, P2, or P3)."
          },
          reasoning: {
            type: Type.STRING,
            description: "A brief justification for the assigned priority."
          }
        },
        required: ['test_case_id', 'priority', 'reasoning']
      }
    }
  },
  required: ['prioritized_cases']
};

export const TRACEABILITY_SYSTEM_INSTRUCTION = `You are a QA Analyst. You have been given a list of test cases and their source user story IDs.
Your task is to create a Requirement-to-Test-Case Traceability Matrix.
For each unique User Story ID present in the test cases, list all the Test Case IDs that cover it.
The output must be a JSON object containing a 'matrix' array. Each object in the array should have a 'story_id' and an array of corresponding 'test_case_ids'.`;

export const TRACEABILITY_RESPONSE_SCHEMA = {
  type: Type.OBJECT,
  properties: {
    matrix: {
      type: Type.ARRAY,
      description: 'The traceability matrix mapping user stories to test cases.',
      items: {
        type: Type.OBJECT,
        properties: {
          story_id: {
            type: Type.STRING,
            description: "The User Story ID (e.g., 'US-101')."
          },
          test_case_ids: {
            type: Type.ARRAY,
            items: {
              type: Type.STRING,
            },
            description: "An array of Test Case IDs that cover this story."
          }
        },
        required: ['story_id', 'test_case_ids']
      }
    }
  },
  required: ['matrix']
};

export const QA_DOCS_GENERATION_INSTRUCTION = `Based on all the provided context (PRD text, images, video frames, etc.), generate a comprehensive QA documentation suite following the structure below. This is for a high-level strategic document.

The output must be a single, well-organized markdown document containing these 8 sections:

1.  **Acceptance Criteria** – Clear, testable, bullet-point criteria per feature or user story.
2.  **QA Test Strategy** – High-level testing approach covering scope, in/out of scope, manual vs automation plan, tools, and entry/exit criteria.
3.  **QA Test Plan** – Detailed plan with timeline, environments, roles, and risk analysis.
4.  **Test Case Matrix** – A markdown table with columns: Test ID, Test Description, Preconditions, Steps, Expected Results, Priority, Test Type.
5.  **Automation Strategy** – Plan for automation including scope, frameworks, and CI/CD integration.
6.  **Bug Triage Workflow** – Description of severity/priority, bug lifecycle, and escalation protocol.
7.  **Release Sign-off Criteria** – A final checklist with defect thresholds, coverage requirements, and stakeholder approvals.
8.  **Post-release QA Monitoring Plan** – Plan for monitoring logs, analytics, and crash reports post-release.

Generate clean, well-organized markdown output, ready to copy into Notion, Confluence, or GitHub wiki.`;
